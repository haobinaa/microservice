## 容器技术

容器其实是一种沙盒技术。 沙盒就像一个集装箱一样, 可以把应用装起来， 应用和应用之间就有了边界而不会互相干扰。

对于一个应用或者程序来说， 一旦被操作系统执行起来， 他就从磁盘上的二进制文件， 变成了计算机内存中的数据、寄存器里面的值、 堆栈中的指令、 被打开的文件以及各种设备的状态信息的集合， 
像这样一个程序运行起来计算机执行环境的总和，就是进程。**而容器的核心功能就是约束和修改进程的动态表现，从而为其创造出一个边界**

对于大多数容器来说， `Cgroups`技术是用来约束的主要手段， `Namespace`技术则是用来修改进程视图的主要方法。


### 容器的隔离技术


#### Namespace 隔离

Namespace是一种修改进程视图的技术， 让线程只能看到某些指定的内容。

Linux系统中创建进程的系统调用函数是clone：
``` 
int pid = clone(main_function, stack_size, SIGCHLD, NULL); 
```
系统调用就会创建一个新的进程， 返回他的pid， 使用clone创建进程的时候可以指定`CLONE_NEWPID`参数：
``` 
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
```
这个时候创建的进程，他所能"感知"到的是一个全新的进程空间， 在这个进程空间里面， 他的PID是1， 而在宿主机真实的进程空间里面， 这个进程的PID还是真实的数值， 比如100。

当执行多次上述的clone调用， 就会创建多个PID namespace， 每个Namespace里面的进程都会认为自己是当前容器里面的1号进程， 他们既看不到宿主机里面的真实进程空间也看不到其他PID Namespace的具体情况。

除了我们刚刚用到的 PID Namespace，Linux 操作系统还有 Mount、UTS、IPC、Network和User这些Namespace， 用来对不同进程进行一些"障眼法"， 在namespace的遮掩下， **容器其实是一种特殊的进程而已**

#### Cgroups限制

虽然容器内的1号进程在namespace "障眼法"的干扰下只能看到容器里的情况， 但是宿主机上， 他仍然是100号进程， 他与其他进程是平等的竞争关系， 他所能够使用到的系统资源(CPU、 内存等)依然随时可能被其他进程吃光。 
这些情况， 不是一个沙盒应该表现出来的情况。

Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。它的最主要作用就是， 限制一个进程组能够使用的资源上线， 包括CPU、内存、磁盘、网络带宽等等

#### 容器中的文件系统

我们希望容器进程看到的文件系统是一个独立的隔离环境而不是继承自宿主机的文件系统， 具体的实现是利用`rootfs`（根文件系统）

rootfs 带有操作系统所包含的文件、配置和目录， 但是并不包括操作系统的内核。docker的镜像就是基于rootfs，他将操作系统所有的文件打包了。而升级镜像的时候， 又只对rootfs做增量改变。